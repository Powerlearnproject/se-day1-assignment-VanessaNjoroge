[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18362154&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Software engineering is the process of applying engineering principles to create new software. It has different cycles which include designing, developing, testing, and, maintenance. This ensures the creation of high-quality software using optimal resources and time.



Identify and describe at least three key milestones in the evolution of software engineering.
1. BEGINING OF SOFTWARE ENGINEERING. The first official use of the term "software engineering" occurred at the 1968 NATO Conference on Software Engineering in Germany. The conference was organized to address the "Software Crisis", where software projects were failing due to increasing complexity, high costs, and poor reliability. Through this, software engineering was formally established as a formal discipline.
2. Introduction of High-Level Programming Languages (1950s-1960s)
Early computers were programmed using machine code (binary) and assembly language, which were difficult to write and debug. The 1950s and 1960s saw the rise of high-level programming languages like FORTRAN (1957) which was used for scientific computing, COBOL (1959) which was Used for business applications and ALGOL (1960) which Influenced modern programming languages like C.
3. The Rise of AI and Machine Learning in Software Engineering (2010s-Present). AI and Machine Learning (ML) are now integrated into software development, leading to AI-powered code generation tools (e.g., GitHub Copilot, ChatGPT), Automated testing and debugging with ML models, and Intelligent systems that adapt and optimize software performance.


   
List and briefly explain the phases of the Software Development Life Cycle.
1. planning phase. This is the stage where you determine everything that you require for the entire cycle. It is important since it ensures that you take control of the process and in the end it helps with risk management.
2. Analysis phase. After the planning, this stage is used to note every requirement needed for the other phases. Requirements can wither be software, hardware, or even human resource. This stage ensures that there is no confusion in the end
3. Design phase. During this phase the software structure is designed. The parties involved here include UI/UX designers, database designers and system designers. This phase gives developers the body to work with making the next phase easier.
4. Coding. This is the implementation phase where developers write lines of code to pring the plan and design to life. The product finally takes shape here.
5. Testing. After writing the code, the lines of codes are tested, so as to ensure software principles are followed and that the writted code follows all the requirements outlined in the planning and analysis phase.
6. Deployment. During this phase, the program is public. It finally is rolled out to the end users and these vary depending on the program or the company.
7. Maintenance. This includes regular updates to the code, fixing any issues that may arise, and making sure the program adapts to new technology and in some cases the needs of the users.
   
   
Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
1. Waterfall methodology is a step by step process of software development while agile methodology is an iterative, flexible, and incremental process for software development. 
2. Waterfall method is more rigid while agile is more flexible due to it's iterative nature
3. Waterfall method only needs user input during the requirements gathering while agile methodology has continous user feedback during the different iterations.
4. Waterfall methodology needs extensive documentation, while agile needs lighter documentation and is more concerned with working software.
5. Waterfall methodology runs in 7 cycles while agile methodology uses sprints with constant feedback from the user

Waterfall method would be more appropriate for well defined projects that are stable and have clear requirements. A good example would be a governement project, a security system, or a hospital system. 
Agile on the other hand would be perfect for projects that are constantly evolving or have no clear requirements. A practical use case would be e-commerce plattforms that need constant updates since they change with more users and new market requirements. It is also ideal for a start-up that is trying to launch a minimum viable product.



Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.
A software developer designs, codes, and implement software applications. They usually do this based on design specifications and they are also resposnible fo debugging and troubleshooting bugs in the software.  
A quality assurance engineer ensures that the software made and deployed meets quality standards by identifying bugs and performance issues before deployment. They do this by developing test cases and conducting perfomance, security and usability testing. 
A project manager Is an important part of the project. They oversee the software development process by ensuring projects are completed on time, within scope, and within budget. They determine the various methods to use. Either waterfall, agile, or the numerous methods available. 



Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.
IDE's 
Boosts Developer Productivity through features like syntax highlighting, code completion, and debugging tool. 
They also speed up the development process and  reduce Errors by providing real-time error detection and debugging features to help developers catch issues early.
IDE's also help to streamline Development Workflow thorough Built-in tools for testing, compiling, and running code 
EXAMPLES OF IDE'S are Visual studio code and PYcharm

VERSION CONTROL SYSTEMS
They enable Collaboration: Multiple developers can work on the same project without conflicts.
They track Code History: Every change is recorded, allowing developers to revert to previous versions if necessary.
They also prevent Data Loss: Since every version is stored, mistakes can be easily undone.
EXAMPLES INCLUDE Git and Mercurial


What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.
1. New technologies coming up rapidly. This is a challenge in recent times especially with the onset of AI. There is rapid rolling out of products which means developers have to learn new technologies that then become obsolete very quickly. The way to overcome this particular challenge is upskilling through online courses, going through various documentation to see what is new, and keeping up with the new technologies through blogs, and attending developer events.
2. Managing tight deadlines. Software development can be a high pressure environment sometimes and developers can be tasked with ensuring that they deliver quality products in a short time. This can be overcome by learning methodologies like scrum to ensure that they relieve the pressure.
3. Security vulnerabilities in the program. The codes written are usually targeted by hackers and this leads to security breaches and customer data can be at risk. One way to overcome this is by conducting security audits and penetration testing.

   

Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.
1. unit testing. Tests individual components or functions of a program in isolation. They are performed by developers during the coding phase.
2. Intergration phase. Tests how different modules or components interact with each other. This ensures that integrated components work correctly as a group.
3. system testing. Tests the complete application as a whole. This Validates that the system meets functional and non-functional requirements.
4.Acceptance testing. This is the final phase of testing. It is normally done to determine whether the software meets business requirements.This stage is typically performed by end-users or clients before deployment.



#Part 2: Introduction to AI and Prompt Engineering

Define prompt engineering and discuss its importance in interacting with AI models.
Prompt engineering is the practice of designing and refining prompts to effectively interact with AI models and generate accurate, relevant, and high-quality responses.
Importance
It ensures that the response is more accurate. Well-crafted prompts help the AI model understand the user's intent more clearly, leading to more accurate answers.
It increases efficiency. Effective prompts reduce the need for follow-up questions, saving time for users and improving the interaction.
It provides a better User experience: Clear prompts lead to more satisfying responses, enhancing the overall user experience.


Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.
VAGUE PROMPT: TELL ME ABOUT CODING
IMPROVED PROMPT: Explain how technology can be used to create more effective systems in the government of a country, with real-life examples of countries
This new prompt gives AI a specific task as opposed to a task like the first one which is broad and vague with no exact responses. 
